import hashlib
import logging
from typing import TypeVar

from flask import g
from pymongo import MongoClient
from pymongo.errors import CollectionInvalid

from src import hive_setting
from src.utils.http_exception import CollectionNotFoundException, AlreadyExistsException
from src.modules.database.mongodb_collection import MongodbCollection, CollectionName
from src.modules.auth.collection_application import CollectionApplication
from src.modules.auth.collection_register import CollectionRegister
from src.modules.database.collection_metadata import CollectionMetadata
from src.modules.files.collection_anonymous_files import CollectionAnonymousFiles
from src.modules.files.collection_file_metadata import CollectionFileMetadata
from src.modules.files.collection_ipfs_cid_ref import CollectionIpfsCidRef
from src.modules.scripting.collection_scripts import CollectionScripts
from src.modules.scripting.collection_scripts_transaction import CollectionScriptsTransaction
from src.modules.subscription.collection_vault import CollectionVault
from src.modules.backup.collection_backup import CollectionBackup


_T = TypeVar('_T', bound=MongodbCollection)


class MongodbClient:
    """ Used to connect mongodb and is a helper class for all mongo database operation. """

    # the database for global data of all users.
    MANAGEMENT_DBNAME = "hive_manage_info"

    def __init__(self):
        self.mongodb_uri = hive_setting.MONGODB_URL
        self.connection = None

    def __get_connection(self):
        if not self.connection:
            self.connection = MongoClient(self.mongodb_uri)
        return self.connection

    def __get_database(self, name):
        """ All databases (manager or user) must exist before call this method.

        Database contains:
            1. one management database with fixed name.
            2. multiple user databases whose name is generated by user did and app did.

        Pymongo create database automatically.
        """
        return self.__get_connection()[name]

    def __exists_database(self, name):
        return name in self.__get_connection().list_database_names()

    def exists_user_database(self, user_did, app_did):
        """ Check if user application database exists. """
        return self.__exists_database(MongodbClient.get_user_database_name(user_did, app_did))

    def exists_user_collection(self, user_did, app_did, col_name, contain_internal=False):
        """ Check if the collection of the user application exists. """

        if not contain_internal and CollectionName.is_user_internal_collection(col_name):
            return False

        database_name = MongodbClient.get_user_database_name(user_did, app_did)
        if not self.__exists_database(database_name):
            return False

        return col_name not in self.__get_database(database_name).list_collection_names()

    @staticmethod
    def get_user_database_name(user_did, app_did):
        # The length of database name is limited to 38 on Atlas Mongodb.
        # https://www.mongodb.com/docs/atlas/reference/free-shared-limitations/ @ key: Namespaces and Database Names
        prefix = 'hive_user_db_' if not hive_setting.ATLAS_ENABLED else 'hu_'

        # The length of md5 string is 32.
        md5 = hashlib.md5()
        md5.update((user_did + "_" + app_did).encode("utf-8"))
        return prefix + str(md5.hexdigest())

    def get_management_collection(self, col_name: str) -> MongodbCollection:
        """ Get the collection used for node management.
        It will be created if not exists.

        TODO: replace this with get_collection
        """

        database = self.__get_database(self.MANAGEMENT_DBNAME)
        if col_name not in database.list_collection_names():
            database.create_collection(col_name)
        return MongodbCollection(database[col_name])

    def get_user_collection(self, user_did: str, app_did: str, col_name: str) -> MongodbCollection:
        """ User application collection belongs to user database and will check the existence.
        Internal collection will be created automatically.

        :raise: CollectionNotFoundException

        TODO: replace this with get_collection
        """
        is_internal = CollectionName.is_user_internal_collection(col_name)

        database = self.__get_database(MongodbClient.get_user_database_name(user_did, app_did))
        if col_name not in database.list_collection_names():
            if is_internal:
                database.create_collection(col_name)
            else:
                raise CollectionNotFoundException(f'Can not find collection {col_name}')

        return MongodbCollection(database[col_name], is_management=False)

    def get_col(self, col_class: type(_T) = MongodbCollection, user_did: str = None, app_did: str = None, use_g=True) -> _T:
        """ Use for get collection with the specific class.
        :param col_class: collection class which derives from class MongodbCollection.
        :param user_did: user did
        :param app_did: application did
        :param use_g: use g values for user collections if user_did or app_did not provided.
        """

        col_name, is_management = col_class.get_name(), col_class.is_management()
        assert col_name

        if use_g and not is_management:  # management collection do not require global values.
            user_did, app_did = user_did if user_did else g.usr_did, app_did if app_did else g.app_did

        if is_management:
            database = self.__get_database(self.MANAGEMENT_DBNAME)
            if col_name not in database.list_collection_names():
                database.create_collection(col_name)
        else:
            database = self.__get_database(MongodbClient.get_user_database_name(user_did, app_did))
            if col_name not in database.list_collection_names():
                if col_class.is_internal():
                    database.create_collection(col_name)
                else:
                    raise CollectionNotFoundException(f'Can not find collection {col_name}')

        col = col_class(database[col_name])
        col.user_did, col.app_did = user_did, app_did
        return col

    def get_col_collection_metadata(self, user_did, app_did) -> CollectionMetadata:
        return self.get_col(CollectionMetadata, user_did=user_did, app_did=app_did)

    def get_col_anonymous_file(self, user_did, app_did) -> CollectionAnonymousFiles:
        return self.get_col(CollectionAnonymousFiles, user_did=user_did, app_did=app_did)

    def get_col_file_metadata(self, user_did, app_did) -> CollectionFileMetadata:
        return self.get_col(CollectionFileMetadata, user_did=user_did, app_did=app_did)

    def get_col_scripts(self, user_did, app_did) -> CollectionScripts:
        return self.get_col(CollectionScripts, user_did=user_did, app_did=app_did)

    def get_col_scripts_transaction(self, user_did, app_did) -> CollectionScriptsTransaction:
        return self.get_col(CollectionScriptsTransaction, user_did=user_did, app_did=app_did)

    def get_col_cid_ref(self) -> CollectionIpfsCidRef:
        return self.get_col(CollectionIpfsCidRef)

    def get_col_application(self) -> CollectionApplication:
        return self.get_col(CollectionApplication)

    def get_col_register(self) -> CollectionRegister:
        return self.get_col(CollectionRegister)

    def get_col_vault(self) -> CollectionVault:
        return self.get_col(CollectionVault)

    def get_col_backup(self) -> CollectionBackup:
        return self.get_col(CollectionBackup)

    def get_user_collection_names(self, user_did: str, app_did: str):
        """ Get collection names belongs to the user's application """

        database = self.__get_database(MongodbClient.get_user_database_name(user_did, app_did))
        names = database.list_collection_names()
        return filter(lambda n: not CollectionName.is_user_internal_collection(n), names)

    def is_internal_user_collection(self, col_name: str):
        return CollectionName.is_user_internal_collection(col_name)

    def create_user_collection(self, user_did, app_did, col_name) -> MongodbCollection:
        """ Create the collection belongs to the user's application.
        Internal collection do not need to call this method.
        """

        database_name = MongodbClient.get_user_database_name(user_did, app_did)
        database = self.__get_database(database_name)
        try:
            return MongodbCollection(database.create_collection(col_name), is_management=False)
        except CollectionInvalid as e:
            logging.info(f'The collection {database_name}.{col_name} already exists.')
            raise AlreadyExistsException()

    def delete_user_collection(self, user_did, app_did, col_name, check_exist=False):
        """ Delete the collection belongs to the user's application.
        Internal collection do not need to call this method.
        """

        database = self.__get_database(MongodbClient.get_user_database_name(user_did, app_did))
        if col_name not in database.list_collection_names():
            if check_exist:
                raise CollectionNotFoundException(f"Can not found user's collection {col_name}")
        else:
            database.drop_collection(col_name)

    def drop_user_database(self, user_did, app_did):
        name = MongodbClient.get_user_database_name(user_did, app_did)
        if self.__exists_database(name):
            self.__get_connection().drop_database(name)

    def get_user_database_size(self, user_did, app_did) -> int:
        """ Get the size of the user database, if not exist, return 0 """
        name = self.get_user_database_name(user_did, app_did)
        if not self.__exists_database(name):
            return 0

        database = self.__get_database(name)

        # count size by command: https://www.mongodb.com/docs/v4.4/reference/command/dbStats/
        return int(database.command('dbstats')['totalSize'])


mcli = MongodbClient()

# # TODO: remove them
# col_collection_metadata: CollectionMetadata = mcli.get_col(CollectionMetadata)
# col_anonymous_file: CollectionAnonymousFiles = mcli.get_col(CollectionAnonymousFiles)
# col_file_metadata: CollectionFileMetadata = mcli.get_col(CollectionFileMetadata)
# col_scripts: CollectionScripts = mcli.get_col(CollectionScripts)
# col_scripts_transaction: CollectionScriptsTransaction = mcli.get_col(CollectionScriptsTransaction)
# col_cid_ref: CollectionIpfsCidRef = mcli.get_col(CollectionIpfsCidRef)
