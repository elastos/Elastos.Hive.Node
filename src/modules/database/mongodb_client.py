import hashlib
import logging
import typing
from datetime import datetime

from bson import ObjectId
from pymongo import MongoClient
from pymongo.errors import CollectionInvalid

from src import hive_setting
from src.utils_v1.constants import DID_INFO_DB_NAME
from src.utils.http_exception import CollectionNotFoundException, AlreadyExistsException, BadRequestException

_T = typing.TypeVar('_T', dict, list, tuple)


class MongodbCollection:
    """ all collection wrapper and base class for specific collection """

    def __init__(self, col):
        self.col = col

    def insert_one(self, doc, contains_extra=True, **kwargs):
        if contains_extra:
            now_timestamp = datetime.utcnow().timestamp()
            doc['created'] = now_timestamp
            doc['modified'] = now_timestamp

        # kwargs are the options
        result = self.col.insert_one(MongodbCollection.convert_oid(doc), **kwargs)
        if not result['inserted_id']:
            raise BadRequestException(msg=f'Failed to insert the doc: {str(doc)}.')

        return {
            "acknowledged": result.acknowledged,
            "inserted_id": ObjectId(str(result.inserted_id))
        }

    def update_one(self, filter_, update, contains_extra=True, **kwargs):
        if contains_extra:
            now_timestamp = datetime.utcnow().timestamp()
            if '$setOnInsert' in update:
                update["$setOnInsert"]['created'] = now_timestamp
            else:
                update["$setOnInsert"] = {"created": now_timestamp}
            if "$set" in update:
                update["$set"]["modified"] = now_timestamp

        # kwargs are the options
        result = self.col.update_one(MongodbCollection.convert_oid(filter_),
                                     MongodbCollection.convert_oid(update), **kwargs)
        return {
            "acknowledged": result.acknowledged,
            "matched_count": result.matched_count,
            "modified_count": result.modified_count,
            "upserted_id": ObjectId(str(result.upserted_id)) if result.upserted_id else None,
        }

    def find_one(self, filter_: dict, **kwargs) -> dict:
        # kwargs are the options
        return self.col.find_one(MongodbCollection.convert_oid(filter_) if filter_ else None, **kwargs)

    @staticmethod
    def convert_oid(value: _T):
        """ try to convert the following dict recursively.

            { "group_id": {"$oid": "5f497bb83bd36ab235d82e6a"} }

        to:

            { "group_id": ObjectId("5f497bb83bd36ab235d82e6a") }
        """
        if type(value) in (list, tuple):
            for o in value:
                if isinstance(o, dict) or type(o) in (list, tuple):
                    MongodbCollection.convert_oid(o)
        elif isinstance(value, dict):
            for k, v in value.copy().items():
                if isinstance(v, dict):
                    if '$oid' in v:
                        value[k] = ObjectId(v['$oid'])
                    else:
                        value[k] = MongodbCollection.convert_oid(v)
                elif type(v) in (list, tuple):
                    value[k] = MongodbCollection.convert_oid(v)
        return value


class MongodbClient:
    """ Used to connect mongodb and is a helper class for all mongo database operation.
    This class is used to replace class `src.utils.db_client.DatabaseClient`.
    """

    def __init__(self):
        self.mongodb_uri = hive_setting.MONGODB_URI
        self.connection = None

    def __get_connection(self):
        if not self.connection:
            self.connection = MongoClient(self.mongodb_uri)
        return self.connection

    def __get_database(self, name):
        """ All databases (manager or user) must exist before call this method.

        Database contains:
            1. one management database with fixed name.
            2. multiple user databases whose name is generated by user did and app did.
        """
        return self.__get_connection()[name]

    @staticmethod
    def __get_user_database_name(user_did, app_did):
        # The length of database name is limited to 38 on Atlas Mongodb.
        # https://www.mongodb.com/docs/atlas/reference/free-shared-limitations/ @ key: Namespaces and Database Names
        prefix = 'hive_user_db_' if not hive_setting.ATLAS_ENABLED else 'hu_'

        # The length of md5 string is 32.
        md5 = hashlib.md5()
        md5.update((user_did + "_" + app_did).encode("utf-8"))
        return prefix + str(md5.hexdigest())

    def get_management_collection(self, col_name) -> MongodbCollection:
        """ Get internal usage collection.

        All manager collection must exist before call this method.
        """
        database = self.__get_database(DID_INFO_DB_NAME)

        # Directly create manager collection if not exists.
        if col_name not in database.list_collection_names():
            database.create_collection(col_name)
        return MongodbCollection(database[col_name])

    def get_user_collection(self, user_did: str, app_did: str, col_name, create_on_absence=False) -> MongodbCollection:
        """ User collection belongs to user database and maybe need check the existence.

        :raise: CollectionNotFoundException
        """
        database = self.__get_database(MongodbClient.__get_user_database_name(user_did, app_did))
        if col_name not in database.list_collection_names():
            if create_on_absence:
                database.create_collection(col_name)
            else:
                raise CollectionNotFoundException()
        return MongodbCollection(database[col_name])

    def create_user_collection(self, user_did, app_did, col_name) -> MongodbCollection:
        database_name = MongodbClient.__get_user_database_name(user_did, app_did)
        database = self.__get_database(database_name)
        try:
            return MongodbCollection(database.create_collection(col_name))
        except CollectionInvalid as e:
            logging.info(f'The collection {database_name}.{col_name} already exists.')
            raise AlreadyExistsException()

    def delete_user_collection(self, user_did, app_did, col_name, check_exist=False):
        database = self.__get_database(MongodbClient.__get_user_database_name(user_did, app_did))
        if col_name not in database.list_collection_names():
            if check_exist:
                raise CollectionNotFoundException()
        else:
            database.drop_collection(col_name)
